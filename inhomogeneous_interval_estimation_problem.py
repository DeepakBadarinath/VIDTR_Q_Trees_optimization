# -*- coding: utf-8 -*-
"""inhomogeneous_interval_estimation_problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nsvu8SG0M8_ttKXIQaRYknZghe-yniHV

Solve the following equation:

$ ((\hat{\sigma}_1, \hat{\tau}_1), (\hat{\sigma}_2, \hat{\tau}_2), ..., (\hat{\sigma}_q, \hat{\tau}_q)) := \arg_{\tau_1, \tau_2, ..., \tau_q} \min_{\sigma_1, \sigma_2, ..., \sigma_q} \sum_{i=1}^n U_{ia} \mathcal{I}[(\sigma_{1} < X[i,1] \leq \tau_{1}),  (\sigma_{2} < X[i,2] \leq \tau_{2}), (\sigma_{3} < X[i,3] \leq \tau_{3}) ...  (\sigma_{q} < X[i,q] \leq \tau_{q})] $

* We solve the above equation by constructing a $Q$-tree with $n$ nodes and $q$ children for each of the nodes. The tree is currently empty of height atleast $\log_q  n$.

* Construct rank operators $r_{i_1}, r_{i_2}, ..., r_{i_q}$ such that we have $r_{i_k} : [n] \to [n]$, $m \to  \text{Rank }(X_{mi_k})$, where we take the rank with respect to the order statistics of $X_{i i_k}$ with $i \in [n]$.

* Insert element $U_{ia}$ by forwarding it through different rank maps $r_k$, in particular $U_{ia} \to r_{i_q} \circ r_{i_{q-1}} \circ ... \circ r_{i_1}(i)$. Therefore the element $U_{ia}$ goes to the leaf with number $r_{i_q} ( r_{i_{q-1}} ( ... ( r_{i_1}(i)...))))$

* Assume the following setup for a better picture of things - a $q$ tree with $N$ nodes $a_1, a_2, ..., a_N$ which denote the different children present.

* Create nodes such that it has the following attributes:
    * **Subtree sums** : Denotes the sum of all the elements in each of the subtrees, i.e $Sum(N) = \sum_{j=i}^{i+k} Sum(a_j.ss)$.

    * **Child indices** : Denotes all the leaf indices that are under the given node, i.e $C(N) := \cup_{i=1}^n C(a_i)$. For leaf index $i$, the child indices is just $i$.

    * **Thresholding sum** : Denotes the minimum sum in all of the subtrees, i.e if we have $q$ children $a_1, a_2 ,..., a_q$ for a certain node, then we must have that the thresholding sum for that node to be given by $ (\hat{i}, \hat{i+k}) := Min_{i,k}(a_i.tc, a_i.ss + a_{i+1}.tc, a_{i}.ss + a_{i+1}.ss + a_{i+2}.tc,  ..., a_{i}.ss + a_{i+1}.ss + ... + a_{i+k-1}.ss + a_{i+k}.tc)$

    * **Chosen indices** : Denotes the leaf indices chosen at each node point, if for instance we pick $a_i.ss + a_{i+1}.ss + ... a_l.ss + a_{l+1}.tc$, then
    $ U(N) := C(a_i) \cup C(a_{i+1}) \cup ... \cup C(a_{i+k-1}) \cup U(a_{i+k})$.

    * When do you not consider splits - Monte Carlo tree search?

* How do we get the minimizing indices from this? \\
    * **IDEA 1**
    * The indices in the summation that we pick would then be $U_{r^{-1}(l_1)}, U_{r^{-1}(l_2)}, ..., U_{r^{-1}(l_k)}$ where $r$ is the composed rank operator.
    * What are the corresponding sigma values that we choose?
    * We then have that the indices being accessed for say $\sigma_1 \in [ X_{r^{-1}(1)i_1}, ..., X_{r^{-1}(k)i_1 }]$.
    * My guess is to pick the max of $X_{r^{-1}(j)i_1}$ for $j \in [k]$. In particular, are we picking $\min([r_{i_1} \circ r^{-1}(j)])$ for $j \in [k]$?
    * The max would be the only term that would allow us to sum over each coefficent $r_{i_1} \circ r^{-1}(j)$ for the differing values of $j \in [k]$
    * Pick the max of  $X_{r^{-1}(j)i_1}$ for $j \in [k]$. In particular, are we picking $\max([r_{i_1} \circ r^{-1}(j)])$ for $j \in [k]$? ie we pick
    * $\tau_1 \in [X_{r^{-1}(1)i_1}, ..., X_{r^{-1}(k)i_1}]$

################################################################################

* **Experimental proposition**:

    * $[l_1, l_2, ..., l_k]$ are contigious and $l_k$ which is the highest index is what we pick.

How do we extend the same to the case when $(X_{.k})$ is a $d_k$ dimensional vector and we have that $\sigma_{k}$ and $\tau_{k}$ are $k$ dimensional vectors? Answer:
1. Flatten $X_i$ values and run the problem for the $\sum_{i=0}^N d_i$ setup. \\
2. Obtain the $\sigma$ and $\tau$ values which would be $\sum_k d_k$ dimensional quantities. \\
3. Regroup each of $\sigma$ and $\tau$ such that it is a grouped vector with group size being $(d_t)$ for all $t$.
"""

#%%

from collections import deque
from graphviz import Digraph
import unittest
from collections import deque
from collections import defaultdict, deque
import math
import numpy as np
import inspect

import os
import platform
import subprocess
from graphviz import Digraph


#%%

def binary_search(arr, target):
    """
    Perform binary search on a sorted array.

    Args:
    ----------------------------------------------------------------------------
        arr (list): Sorted list of elements to search.
        target: Value to search for.

    Returns:
    ----------------------------------------------------------------------------
        int: Index of target if found, else -1.
    """
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

#################################################################################
#################################################################################

def construct_operator(X_vals):
    '''
    Given a list [X_vals[0], X_vals[1], ..., X_vals[n-1]] denoting the different
    X_values, construct a map.

    r : [0,1,...,n-1] \to [0,1,...,n-1] such that r(i) := Position of X_vals[i]
    in the order statistics of X_vals.

    Make it such that the rank operator has access to X_vals in sorted form; for
    each input i, we would then search using
    binary search the location of this value.

    Parameters:
    ----------------------------------------------------------------------------
    X_vals : list
             The list of X values.
    '''

    sorted_x_vals = sorted(X_vals)
    print(sorted_x_vals)

    def rank_operator(i, sorted_vals = sorted_x_vals):

        print(f'i is {i}')
        print(f'Sorted vals are {sorted_vals}')
        print(f'X vals are {X_vals}')

        if i < 0 or i >= len(X_vals):
            raise IndexError(f"Index {i} out of bounds. List has {len(X_vals)} elements.")

        posititon = binary_search(sorted_vals, X_vals[i])
        return posititon

    return rank_operator

def construct_extended_operator(X_vals, N):
    '''
    Given a list [X_vals[0], X_vals[1], ..., X_vals[n-1]] denoting the different
    X_values, construct the extended rank operator.

    r : [0,1,...,n-1] \to [0,1,...,n-1] such that r(i) := Position of X_vals[i]
    if X_vals[i] \in [0,1,2,...,n-1]. For values of i \geq n, we return i.

    Make it such that the rank operator has access to X_vals in sorted form; for
    each input i, we would then search using
    binary search the location of this value.

    Parameters:
    ----------------------------------------------------------------------------
    X_vals : list
             The list of X values.

    N : int
        The length of the list.

    Returns:
    ----------------------------------------------------------------------------
    rank_operator : function
                    The rank operator.
    '''

    sorted_x_vals = sorted(X_vals)
    print(sorted_x_vals)

    def rank_operator(i, sorted_vals = sorted_x_vals):

        if i < 0 or i >= N:
            raise IndexError(f"Index {i} out of bounds. List has {len(X_vals)} and N is {N}.")

        elif i >= len(X_vals):
            return i

        else:
            posititon = binary_search(sorted_vals, X_vals[i])
            return posititon

    return rank_operator


#%%


X_vals = [0, -1, 2, 4, -4, 24, 53, 6, 534, 63, 45233]
rank_op = construct_operator(X_vals)

# [-4, -1, 0, 2, 4]

rank_op(2)

new_X_vals = [-1, 4, 2, 10]
new_rank_op = construct_operator(new_X_vals)

# [-1, 2, 4, 10]

new_rank_op(0)


#%%

class QTreeNode:

    def __init__(self, subtree_sum=0, thresholding_cost=0, children=[],
                 upper_bound=0, lower_bound=0, child_indices= [], chosen_indices=[]):

        '''
        The nodes which we use in the QTree.

        Parameters:
        ------------------------------------------------------------------------
        subtree_sum : int
                      The value of the node.

        thresholding_cost : int
                            The thresholding cost of the node.

        children : list
                   The children of the node.

        upper_bound : float
                      The upper bound for the thresholding cost for the node

        lower_bound : float
                      The lower bound for the node.

        child_indices : set
                        The child indices that are present for that node.

        chosen_indices : set
                         The chosen indices present for that node.

        index : int
                The index of the node.


        '''

        self.thresholding_cost = thresholding_cost
        self.upper_bound = upper_bound
        self.lower_bound = lower_bound
        self.children = []
        self.child_indices = child_indices
        self.chosen_indices = chosen_indices
        self.subtree_sum = subtree_sum
        self.index = 0

    def add_child(self, child_node, q):

        '''
        Add a child to the current node.

        Parameters:
        ------------------------------------------------------------------------
        child_node : QTreeNode
                     The child node to add.

        q : int
            The branching factor of the tree.

        '''

        if len(self.children) >= q:
            raise ValueError(f"Cannot add more than {q} children.")
        self.children.append(child_node)


    @staticmethod
    def kanades_algorithm(a, node_children=[]):
        '''
        Given an array a of length n. Find the indices j_hat > i_hat such that:
        j_hat, i_hat := min_{j,i} \sum_{k=i}^j a[k].

        Parameters:
        ------------------------------------------------------------------------
        a : np.array
            The array we wish to find the indices over which we want to minimize
            the double index problem.

        Returns:
        ------------------------------------------------------------------------
        (min_start, min_end, min_sum) := indices i and j such that j >= i and
                                         the min_sum which minimizes the sum

        '''
        n = len(a)

        curr_sum = a[0]

        if a[0] < 0:
            min_sum = a[0]
            min_start = 0
            min_end = 0
        else:
            min_sum = 0
            min_start = 0
            min_end = 0

        start = 0
        for i in range(1,n):
            curr_sum += a[i]

            if curr_sum < min_sum:
                min_sum = curr_sum
                min_start = start
                min_end = i  # inclusive

            if curr_sum > 0:
                print('An instance where a new subarray was formed is created')
                curr_sum = 0
                start = i + 1  # start new subarray

        return (min_start, min_end, min_sum)  # indices i and j such that j >= i and sum is minimized

    @staticmethod
    def choose_indices(node_children, i, j):
        '''
        Given node_children and corr indices j > i for the children, find which indices
        we pick. The formula is

        U(a_i) = C(a_i) \cup C(a_{i+1}) \cup ... \cup C(a_{i+k-1}) \cup U(a_{i+k})

        where i + k = j

        Parameters:
        ------------------------------------------------------------------------
        node_children : list
                        The children of the node.

        i : int
            The start index.

        j : int
            The end index.

        Returns:
        ------------------------------------------------------------------------
        chosen_indices : list
                         The indices we end up picking from the children and the main node

        '''
        chosen_indices = []
        for ind in range(i,j):
            chosen_indices.extend(node_children[ind].child_indices)
        chosen_indices.extend(node_children[j].chosen_indices)
        return chosen_indices

    def update_aggregates_bottom_up(self):

        # Step 1: BFS to group nodes by depth
        level_nodes = defaultdict(list)
        queue = deque([(self, 0)])
        max_depth = 0

        while queue:
            node, depth = queue.popleft()
            level_nodes[depth].append(node)
            max_depth = max(max_depth, depth)
            for child in node.children:
                queue.append((child, depth + 1))

        # Step 2: Bottom-up update
        index_counter = 0  # Initialize a counter for leaf indexing

        for depth in reversed(range(max_depth)):
            for node in level_nodes[depth]:
                if node.children:
                    # Compute subtree sum and child indices
                    node.subtree_sum = sum(child.subtree_sum for child in node.children)
                    node.child_indices = set()
                    for child in node.children:
                        node.child_indices.update(child.child_indices)

                    kanade_array = []
                    curr_thresholding_cost = node.children[0].thresholding_cost
                    kanade_array = [curr_thresholding_cost]

                    min_thresholding_cost = curr_thresholding_cost

                    for i, child in enumerate(node.children[1:]):
                        prev_child = node.children[i-1]
                        curr_thresholding_cost += (
                            child.thresholding_cost + prev_child.subtree_sum - prev_child.thresholding_cost
                        )

                        kanade_array.append(curr_thresholding_cost)

                    (start, end, cost) = QTreeNode.kanades_algorithm(kanade_array)

                    chosen_indices = QTreeNode.choose_indices(node_children=node.children,
                                                              i=start,
                                                              j=end)

                    print('Chosen indices are')
                    print(chosen_indices)

                    node.chosen_indices = chosen_indices
                    node.thresholding_cost = cost
                    node.upper_bound = end
                    node.lower_bound = start
                    node.index = index_counter
                    index_counter += 1

                else:
                    # Leaf: assign index and initialize attributes
                    node.index = index_counter
                    node.subtree_sum = 1  # Typically 1 for a leaf
                    node.child_indices = {index_counter}
                    index_counter += 1


    def get_leaves(self):

        if len(self.children) == 0:
            return [self]
        leaves = []
        for child in self.children:
            leaves.extend(child.get_leaves())
        return leaves

#%%%

class QTree:

    '''
    A tree based structure with each node being a QTreeNode and q children per node.

    Parameters:
    ------------------------------------------------------------------------
    root : QTreeNode
           The root of the tree.

    q : int
        The branching factor of the tree.

    leaf_count : int
                 The number of leaves in the tree.
    '''


    def __init__(self, root, q, leaf_count=0):

        self.root = root
        self.q = q
        self.leaf_count = leaf_count

    def add_to_ith_leaf(self, i, val):

        leaves = self.root.get_leaves()
        print(f'We attempt to insert {val} in the {i}th leaf location')

        print('Leaf vals are')
        for leaf in leaves:
            print(leaf.subtree_sum)

        if i < 0 or i >= len(leaves):
            raise IndexError(f"Leaf index {i} out of bounds. Tree has {len(leaves)} leaves.")
        leaf = leaves[i]
        leaf.subtree_sum += val
        leaf.thresholding_cost += val  # optionally track cost change
        leaf.upper_bound += val
        leaf.lower_bound += val

    @staticmethod
    def build_tree_with_at_least_n_leaves(N, q,
                                          upper_leaf_value=0,
                                          lower_leaf_value=0,
                                          leaf_cost=0,
                                          subtree_sum = 0,
                                          upper_internal_value=0,
                                          lower_internal_value = 0,
                                          internal_cost=0):

        """
        Build a QTree with at least N leaves (smallest full q-ary tree >= N leaves),
        and assign a unique index to each node in the tree.
        """

        # Find smallest k such that q^k >= N
        k = 0
        while q ** k < N:
            k += 1
        total_leaves = q ** k

        index_counter = 0  # Unique index assigned to each node

        root = QTreeNode(subtree_sum=subtree_sum,
                         thresholding_cost=internal_cost,
                         children=[],
                         upper_bound=upper_internal_value,
                         lower_bound=lower_internal_value)

        root.index = index_counter
        index_counter += 1

        queue = deque([root])

        leaf_node_count = 0
        current_level = 0

        while current_level < k:
            level_size = len(queue)
            for _ in range(level_size):
                parent = queue.popleft()
                for _ in range(q):
                    if current_level == k - 1:
                        # Create leaf node

                        leaf = QTreeNode(subtree_sum=subtree_sum,
                                         thresholding_cost=internal_cost,
                                         children=[],
                                         upper_bound=upper_leaf_value,
                                         lower_bound=lower_leaf_value)

                        leaf.child_indices = [leaf_node_count]
                        leaf.chosen_indices = [leaf_node_count]
                        leaf.index = index_counter
                        index_counter += 1
                        parent.add_child(leaf, q)
                        leaf_node_count += 1

                    else:

                        # Create internal node

                        internal = QTreeNode(subtree_sum=subtree_sum,
                                             thresholding_cost=internal_cost,
                                             children=[],
                                             upper_bound=upper_internal_value,
                                             lower_bound=lower_internal_value)

                        internal.index = index_counter
                        index_counter += 1
                        parent.add_child(internal, q)
                        queue.append(internal)

            current_level += 1

        tree = QTree(root, q, leaf_count=leaf_node_count)
        return tree

    def get_leaves(self):
        return self.root.get_leaves()

    def print_node_summary(self):

        print('Node summary is as follows:')
        print(f'Node thresholding cost is {self.root.thresholding_cost}')
        print(f'Node subtree sum is {self.root.subtree_sum}')

    def print_summary(self):

        self.print_node_summary()

        for child in self.root.children:
            child_tree = QTree(child, self.q)
            child_tree.print_summary()

    def to_graphviz(self, filename=None, view=False):
        """
        Render the QTree as a Graphviz Digraph.
    
        Parameters:
        ------------------------------------------------------------------------
        - filename: if given, saves the graph to a file (without extension)
        - view: if True, opens the file after rendering
        """
        dot = Digraph()
        node_counter = [0]
    
        print('We access the to_graphviz command here')
    
        def add_nodes_edges(node, parent_id=None):
            node_id = str(node_counter[0])
            node_counter[0] += 1
    
            label = (
                f"Value: {node.subtree_sum}\n"
                f"Cost: {node.thresholding_cost}\n"
                f"Upper_Bound: {node.upper_bound}\n"
                f"Lower_Bound: {node.lower_bound}\n"
                f"Chosen_Indices: {node.chosen_indices}\n"
                f"Child_Indices : {node.child_indices}"
            )
            dot.node(node_id, label)
    
            if parent_id is not None:
                dot.edge(parent_id, node_id)
    
            for child in node.children:
                add_nodes_edges(child, node_id)
    
        add_nodes_edges(self.root)
    
        if filename:
            filepath = dot.render(filename, format='png', view=False)  # Render but don't open yet
            if view:
                # Explicitly open the image depending on OS
                if platform.system() == 'Darwin':  # macOS
                    subprocess.run(['open', filepath])
                elif platform.system() == 'Windows':
                    os.startfile(filepath)
                elif platform.system() == 'Linux':
                    subprocess.run(['xdg-open', filepath])
                else:
                    print(f"Unsupported platform: {platform.system()}")
        else:
            if view:
                print("Warning: Cannot open view because no filename was given.")
    
        return dot
#%%

# Add a test to create a tree with 10 leaves and branching factor = 3
# Check how the node distribution occurs here. To this we add values -5, 2, -6, 10, 3, 1, 3.5, 4, 5, -0.3

# Update aggregates and manually check if the answers make sense. - check if answer makes sense on ChatGPT.

n = 10
q = 2
vals = [-5, 2, -6, 10, 3, 1, 3.5, 4, 5, -0.3]

tree = QTree.build_tree_with_at_least_n_leaves(n, q)

for i, val in enumerate(vals):
    tree.add_to_ith_leaf(i, val)

tree.print_summary()
tree.root.update_aggregates_bottom_up()

tree.to_graphviz(filename = 'random_tree',
                 view=True)

#%%

'''
 Create functionality as in the VIDTR, where we try and solve the optimization problem
 \arg \min_{a_{i_1}, b_{i_1},...,a_{i_q}, b_{i_q}} [\sum_{i=1}^n U_{ia} I[ a_{i_1} < X_{ii_1} \leq b_{i_1}, ..., a_{i_1} < X_{ii_q} \leq b_{i_q}]]

 Insert U_{ia} to the leaf whose position is given by (r_{i_q} \circ r_{i_{q-1}} \circ ... \circ r_{i_1})(i).

 Create a class called UpperBoundTreeSolver that takes as input U_{ia} for all i \in [N].
 We first compute the composed rank operators and then we insert U_{ia} one after another
 to the leaves as given by the answer from the composed rank operators.
'''

class UpperBoundTreeSolver:

    def __init__(self, U_vals, X_values):

        '''
        We aim to solve the following equation:
        ------------------------------------------------------------------------
            \arg \min_{c_{i_1}, c_{i_2},..., c_{i_q}} [\sum_{i=1}^n U_{i} I[X_{i:1} \leq c_{i_1}, ..., X_{i:i_q} \leq c_{i_q}]]

        Parameters:
        ------------------------------------------------------------------------
        U_vals : np.array[n]
                 The U_vals which we eventually insert into our tree

        X_values : np.array[n,q]
                 The X array in the above optimization                          

        '''                                                                    

        self.U_vals = U_vals
        self.X_values = X_values
        self.q = X_values.shape[1]
        self.n = len(U_vals)

    @staticmethod
    def composition_map(maps):

        '''
        Given maps m_0,m_1,..., m_{n-1}, s.t m_i :[n] \to [n], compose them to get a map
        from [n] \to [n], the composition looks like,

        m_{n-1} \circ m_{n-2} \circ ... \circ m_0 : [n] \to [n]

        Parameters:
        ------------------------------------------------------------------------
        maps : list
               List of maps that we wish to compose

        '''

        def composed_map(x):
            y = x
            for i, func in enumerate(maps):
                y = func(y)

            return y

        return composed_map

    @staticmethod
    def make_inverse(a, n):
        # Step 1: Build the forward map as a list
        a_list = [a(i) for i in range(0, n)]  # 1-based indexing

        # Step 2: Construct the inverse map
        a_inv_list = [0] * n
        for i in range(n):
            val = a_list[i]
            a_inv_list[val] = i  # Because val = a(i+1)

        # Step 3: Return inverse function
        def a_inv(i):
            if i >=n:
                print(f'i is {i} where as n is {n}')
                raise ValueError(f"Cannot add more than {n} children.")

            return a_inv_list[i]  # Again 1-based indexing

        return a_inv

    def build_composed_rank_operator(self, N):

        '''
        Build operators r_{q}, r_{q-1}, r_{q-2}, ..., r_{1}, where r_i = rank_operator(X_values[:,i])
        and then compose them to get r_q \circ r_{q-1} \circ ... \circ r_{1}.

        '''

        rank_operators = []

        for i in range(self.q):
            rank_operators.append(construct_extended_operator(self.X_values[:,i], N))

        composed_rank_operator = UpperBoundTreeSolver.composition_map(rank_operators)

        return composed_rank_operator

    @staticmethod
    def composition_map(maps):

        '''
        Given maps m_0,m_1,..., m_{n-1}, s.t m_i :[n] \to [n], compose them to get a map
        from [n] \to [n], the composition looks like,

        m_{n-1} \circ m_{n-2} \circ ... \circ m_0 : [n] \to [n]

        Parameters:
        ------------------------------------------------------------------------
        maps : list
               List of maps that we wish to compose

        '''

        def composed_map(x):
            y = x
            for i, func in enumerate(maps):
                y = func(y)

            return y

        return composed_map

    def compute_minimizers(self, show_pic = False, save_location='', filename=''):

        '''
        Compute the minimizers of the above equation:

        \arg \min_{(a_{i_1},b_{i_1}), (a_{i_2}, b_{i_2}),..., (a_{i_q},b_{i_q})} [\sum_{i=1}^n U_{i} I[X_{i:1} \in [a_{i1}, b_{i1}], ..., X_{i:q} \in [a_{iq}, b_{iq}]]

        1. Construct empty Q_tree with atleast n leaves.
        2. Construct composed_rank_operator given the X values.
        3. Insert U_{ia} into the c.r.o(i)th leaf position.
        4. Update the aggregates of the tree. Obtain the chosen chosen indices from the leaves = [1,2,...,k].
        5. This implies that we pick

        Parameters:
        ------------------------------------------------------------------------
        show_pic : bool
                   Whether to show the tree or not.

        save_location : str
                        The location to save the tree.

        Returns:
        ------------------------------------------------------------------------
        sigma_vals : np.array[q]
                     The lower bounds of the above equation.

        tau_vals : np.array[q]
                   The upper bounds for the above equation 
        '''

        self.tree = QTree.build_tree_with_at_least_n_leaves(self.n, self.q)
        composed_rank_operator = self.build_composed_rank_operator(self.tree.leaf_count)
        inverse_rank_map = UpperBoundTreeSolver.make_inverse(composed_rank_operator, self.tree.leaf_count)

        for i, val in enumerate(self.U_vals):

            insert_location = composed_rank_operator(i)
            print(f'We insert {val} into {insert_location}')

            self.tree.add_to_ith_leaf(insert_location, val)

        self.tree.root.update_aggregates_bottom_up()
        
        if show_pic:
            self.tree.to_graphviz(view=True, filename = filename)

        sigma_vals = []
        tau_vals = []

        running_max_index = max(self.tree.root.chosen_indices)
        
        running_min_index = min(self.tree.root.chosen_indices)
        
        print('Chosen indices are')
        print(self.tree.root.chosen_indices)
        
        for d in reversed(range(self.q)):

            rank_operator = construct_extended_operator(self.X_values[:,d], N = self.tree.leaf_count)
            inverse_operator = UpperBoundTreeSolver.make_inverse(rank_operator, self.tree.leaf_count)

            if d == ((self.q)-1):
                print('Operator is assigned as inverse operator')
                curr_operator = inverse_operator
                print(f'Operator is {curr_operator}')
            else:
                curr_operator = UpperBoundTreeSolver.composition_map([inverse_operator,
                                                                      curr_operator])
            running_min_index = curr_operator(running_min_index)
            running_max_index = curr_operator(running_max_index)

            print(f'Running max index is {running_max_index}')
            print(f'Running min index is {running_min_index}')
                                                                                
            print('Length of X_values is')
            print(len(self.X_values))
            
            print('Type of X_values is')
            print(type(self.X_values))
            
            if running_max_index >= self.X_values.shape[0]:
                running_max_index = self.X_values.shape[0] - 1
                
            if running_min_index >= self.X_values.shape[0]:
                running_min_index = self.X_values.shape[0] - 1

            min_x_val = self.X_values[running_min_index,d]
            max_x_val = self.X_values[running_max_index,d]

            sigma_vals = sigma_vals + [min_x_val]
            tau_vals = tau_vals + [max_x_val]

        if show_pic:
            self.tree.to_graphviz(filename = filename, view=True)

        print(f'Minimizing sigmas are {sigma_vals}')
        print(f'Minimizing taus are {tau_vals}')

        return sigma_vals, tau_vals

#%%%

# Tests for UpperBoundTreeSolver

# len(U_vals) = 10

U_vals = [-5, 2, -6, 10, 3, 1, 3.5, 4, 5, -0.3, 5, 7, 11, -50]

n = len(U_vals)
q = 2

# q = 3
# Branching factor for the above

X_vals = np.random.rand(n,q)

print('X_vals is')
print(X_vals)

ubts = UpperBoundTreeSolver(U_vals, X_vals)

sigma_vals, tau_vals = ubts.compute_minimizers(filename = 'ubts_tree',
                                               show_pic=True)

#%%

class InhomogeneousUpperBoundTreeSolver:

    def __init__(self, U_vals, X_vals):

        '''
        We aim to solve the following equation:
        ------------------------------------------------------------------------
            \arg \min_{\sigma_{i_1}, \tau_{i_1},..., \sigma_{i_q}, \tau_{i_q}} [\sum_{i=1}^n U_{i} I[ \sigma_{i_1} < X_{i:1} \leq \tau_{i_1}, ..., \sigma_{i_q} < X_{i:i_q} \leq \tau_{i_q}]]


        Here we assume that each of the $X_{i:k}$ values are of dimension $d_k$.

        Parameters:
        ------------------------------------------------------------------------
        U_vals : np.array[n]
                 The U_vals which we eventually insert into our tree

        X_vals : list
                 Here we assume X_vals[k] := X_{.:k} for . \in range(n)
                 In particular X_vals[k] is an np.array[n,d_k]                 
                 Here we have X_vals to be a list of length q.

        '''

        self.U_vals = U_vals
        self.X_vals = X_vals
        self.q = np.sum([X_vals[i].shape[1] for i in range(len(X_vals))])
        self.n = len(U_vals)
        self.X_homo = None

        print(inspect.signature(UpperBoundTreeSolver.__init__))

        # Get detailed parameter info
        for name, param in inspect.signature(UpperBoundTreeSolver.__init__).parameters.items():
            if name != 'self':
                print(f"Parameter: {name}, Default: {param.default}")
        

    def homogenize_X(self):

        '''
        We homogenize X so that we can use it in the above UpperBoundTreeSolver
        method.

        Convert X_vals to an array of size (n, \sum_{k=1}^q d_k).

        '''
        X_homo = np.concatenate(self.X_vals, axis=1)
        self.X_homo = X_homo
        return X_homo


    def solve_homo_equation(self, show_tree = False, filename = ''):

        '''
        Solve the homogeneous equation using UpperBoundTreeSolver.

        '''
        self.X_homo = np.concatenate(self.X_vals, axis=1)
        
        print('The input to the UBTS equation is')
        print(self.X_homo)
        
        ubts_homo = UpperBoundTreeSolver(self.U_vals, self.X_homo)
        
        print('X_homo is')
        print(self.X_homo)
        
        sigma_vals, tau_vals = ubts_homo.compute_minimizers()
        
        if show_tree:
            print('Show_tree is true')
            print('We show tree!!!!')
            
            ubts.tree.to_graphviz(view=True, filename = filename)
        
        self.homo_tree = ubts.tree
        
        return sigma_vals, tau_vals

    def dehomogenize_soln(self, homo_sigma_vals, homo_tau_vals):
        '''
        Given the homogeneous sigma_vals and tau_vals, dehomogenize them by grouping
        them into the correct dimensions as given by X_vals.

        Parameters:
        ------------------------------------------------------------------------
        homo_sigma_vals : np.array[\sum_{i=1}^{q} d_i]
                          The homogeneous sigma_vals.

        homo_tau_vals : np.array[\sum_{i=1}^{q} d_i]
                        The homogeneous tau_vals.

        Returns:
        ------------------------------------------------------------------------
        sigma_vals : list
                     List of q elements where each element is an np.array[n,d_k]

        tau_vals : list
                   List of q elements where each element is an np.array[n,d_k]
        '''
        d_dims = [X.shape[1] for X in self.X_vals]  # list of d_k values
        n = self.X_vals[0].shape[0]  # number of rows

        sigma_vals = []
        tau_vals = []

        start = 0
        for d_k in d_dims:
            end = start + d_k
            sigma_vals.append(homo_sigma_vals[start:end])
            tau_vals.append(homo_tau_vals[start:end])
            start = end

        return sigma_vals, tau_vals

    def compute_minimizers(self, show_tree=False, filename = ''):

        '''
        We list how to solve for sigma and tau values in the
        inhomogeneous multidimensional setup.
        
        Output:
        -----------------------------------------------------------------------
        
        
        '''
        self.homogenize_X()
        
        homo_sigma_vals, homo_tau_vals = self.solve_homo_equation(show_tree=show_tree, filename=filename)
                                                                                
        sigma_vals, tau_vals = self.dehomogenize_soln(homo_sigma_vals, homo_tau_vals)

        return sigma_vals, tau_vals
                                                                                
#%%

q = 3
N = 10

d0 = 3
d1 = 2
d2 = 4

X0 = np.random.randn(N, d0)
X1 = np.random.randn(N, d1)
X2 = np.random.randn(N, d2)

X_vals = [X0, X1, X2]
U_vals = np.random.randint(-10, 10, size=N)

iubts = InhomogeneousUpperBoundTreeSolver(U_vals, X_vals)

sigma_vals, tau_vals = iubts.compute_minimizers(filename = 'inhomo_tree', show_tree=True)

#%%

print(sigma_vals)
print(tau_vals)

# Length = q  with dimensions being determined by d0,d1, and d2.